\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[french]{babel}

\usepackage{float}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{siunitx}
\usepackage{amsmath}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}
\usetikzlibrary{plotmarks}
\usetikzlibrary{arrows.meta}
\usepgfplotslibrary{patchplots}
\usepackage{grffile}
\pgfplotsset{plot coordinates/math parser=false}
\newlength\figureheight
\newlength\figurewidth
  
\usepackage{graphicx}
\usepackage{hyperref}
\newcommand{\TF}{\operatorname{TF}}
\newcommand{\sinc}{\operatorname{sinc}}

\title{Rapport de projet -- Traitement du signal}
\author{Florent Puy, Ewen Le Bihan}

\date{ENSEEIHT, département Sciences du Numérique}

\begin{document}
\maketitle



\tableofcontents

\section{Introduction}

Dans ce projet, nous avons eu à implémenter un modem suivant les règles V21 de l'union internationnale des télécommunications (UIT) en Matlab. Nous utiliserons la méthode de la modulation en fréquence numérique.

\section{Modem en fréquence}

Nous allons tout d'abord réaliser un signal NRZ binaire à partir duquel nous construirons ensuite un signal sinusoïdal modulé fréquence $F_0=\SI{1180}{\hertz}$ pour les bits 0 et de fréquence $F_1=\SI{980}{\hertz}$ pour les bits 1.
Nous comparerons ensuite les densités spéctrales de puissance théorique et pratique du signal NRZ et du signal modulé en fréquence.

\subsection{Génération d'un signal NRZ}

On génère tout d'abord un signal NRZ prennant deux valeurs, 0 ou 1, générées aléatoirement d'une durée $T_s=1/300 s$. On effectue cela sur $N_s$ périodes. Voici les résultats ainsi obtenus.

\input{figures.6k2k.61/nrz-aleatoire.tex}

On calcule ensuite la densité spectrale de puissance de ce signal NRZ en utilisant la fonction $pwelch$ de Matlab utilisant un périodogramme de Welch.

On calcule ensuite la densité spectrale théorique vue en cours d'un signal NRZ:
\[
S_\text{NRZ}(f)=\frac{1}{4} T_s \sinc^2(\pi f T_s)+\frac{1}{4} \delta(f)
\]

On peut déormais comparer la densité spéctrale de puissance théorique à celle calculée:

\input{figures.6k2k.61/dsp-nrz-pratique-theorique.tex}

\subsection{Génération d'un signal modulé en fréquence}

Pour construire notre signal modulé en fréquence nous allons nous baser sur le signal NRZ et sur une simple sinusoïdale. Lorsque le signal NRZ vaut 0, la fréquence de la sinusoïdale sera $F_0=\SI{1180}{Hz}$ et lorsqu'il vaut 1 la sinusoïdale sera de fréquence $F_1=\SI{980}{Hz}$. Au final, notre signal modulé suit la formule suivante:
\[
\operatorname{modulé}(t)=\operatorname{NRZ}(t) \cos(2\pi F_1 t + \phi_1) + (1-\operatorname{NRZ}(t)) \cos(2 \pi F_0 t + \phi_1)
\]
$\phi_1$ et $\phi_2$ étant des déphasages tirés aléatoirement dans $[0, 2\pi]$

On obtient ainsi le signal suivant:

\input{figures.6k2k.61/nrz-module-en-frequence.tex}

On calcule ensuite la densité spectrale de puissance de ce signal NRZ en utilisant la fonction \verb|pwelch| de Matlab utilisant un périodogramme de Welch. 
On obtient ceci:

\input{figures.6k2k.61/dsp-nrz-module-en-frequence.tex}


\section{Canal de transmission à bruit additif, blanc et Gaussien}

Dans cette section, nous allons tenter de simuler un bruit blanc Gaussion que nous additionnerons à notre signal modulé en fréquence afin de modéliser le signal reçu par le modem.
Le bruit simulé sera généré aléatoirement grâce au module \verb|rand| de Matlab et sera de puissance $\sigma^2$ avec:

\[
\sigma=\sqrt{\frac{S_\text{module}}{10^{\operatorname{SNR}/10}}} \huge
\]

avec $S_\text{module}$ représentant la densité spectrale de puissance du signal modulé en fréquence et $\operatorname{SNR}$ le rapport signal sur bruit (signal to noise ratio) que nous fixerons à 10 par la suite.

\input{figures.6k2k.61/signal-bruite.tex}

\section{Démodulation par filtrage}

On souhaite désormais reconstituer le signal de départ. Pour cela, nous allons procéder à un filtrage passe bas d'une part et passe haut d'autre part, avec une fréquence de coupure $F_c=\frac{F_0+F_1}{2}$. Nous ferons ensuite passer chacun des signaux filtrés par un détecteur d'énergie qui permettra de reproduire de signal binaire initial de manière fidèle.

\paragraph{Filtre passe haut}
Pour le passe haut, nous allons utiliser un filtre de réponse impulsionnelle suivante:
\[
h_\text{haut}(t) = \frac{2 F_c}{F_e} \sinc(2 F_c t)
\]
\\
et donc \[H_\text{haut}(f) = \TF(h_\text{haut}(t))
\]

\paragraph{Filtre passe bas}

\[
H_\text{bas}(f) = 1-H_\text{haut}(f)
\]

Les réponses des filtres sont les suivantes:

\input{figures.6k2k.61/reponse-impulsionnelle-bas-haut.tex}

\paragraph{}

\input{figures.6k2k.61/reponse-frequentielle-bas-haut.tex}

Les sorties des filtres sont les suivantes

\input{figures.6k2k.61/signal-demodule.tex}

\subsection{Détection d'énergie}


Avec ces signaux ainsi filtrés, nous désirons reconstituer le signal de base. Pour cela nous allons utiliser un détecteur d'énergie.
Nous divisons nos signaux en périodes $T_s$ et sur chaque période nous calculons l'énergie suivant la formule suivante:
\[
E=\sum_{i=1}^{N_s} x_n^2
\]
Enfin, on compare cette énergie à un seuil $K$ qu'on fixera à la moyenne des énergies du signal.
Pour le signal en sortie du passe bas par exemple, si $E>K$ alors le signal reconstitué sera égal à 1 sur cette période $T_s$, sinon il sera égal à 0.

Voici les figures obtenues grâce à cette méthode.
\input{figures.6k2k.61/nrz-aleatoire.tex}

\input{figures.6k2k.61/signal-reconstitue.tex}

On peut désormais calculer le taux d'erreur binaire $\eta$ correspondant au nombre de bits mal transmits sur le nombre de bits total.
Avec $F_1=980Hz$ et $F_0=1180Hz$ on obtient un taux d'erreur binaire $\eta=9\%$
\subsection{Modification du démodulateur} 

\subsubsection{Modification du nombre de coefficients}

On remarque qu'avec $F_1=980Hz$ et $F_0=1180Hz$, le nombre de coefficient n'a que très peu d'influence sur le taux d'erreur binaire.

%%%%%%%%%%%%%%%%%%%%%%%%%% A CHECK %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
En passant à 201 coefficients, le taux d'erreur reste de 0.2662.
En passant à 61 coefficients, le taux d'erreur reste de 0.0725. 
% V21 : 0.0912 pour les deux quantités de coefficients

\input{figures.6k2k.201/signal-reconstitue.tex}

\input{figures.6k2k.61/reponse-frequentielle-bas-haut.tex}

\input{figures.6k2k.201/reponse-frequentielle-bas-haut.tex}

\input{figures.6k2k.201/reponse-impulsionnelle-bas-haut.tex}

\subsubsection{Modification de la fréquence de coupure}

% TODO


\section{Démodulateur de fréquence adapté à la norme V21}

\subsection{Contexte de synchronisation idéale}

Nous allons ici introduire une nouvelle méthode de démodulation plus adaptée à la norme V21.
La multiplication du signal avec le cosinus correspondant (par exemple) au bit 1 donne, en fonction du temps, une mesure de la synchronisation entre le signal et ce cosinus: plus le résultat est proche de 1, plus les signaux sont synchronisés à cet instant, et donc plus le signal est susceptible d'être un bit 1.

\begin{center}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
        \begin{axis}[
            ymax=1.1, ymin=-1.1,
            ylabel={Amplitude},
            xlabel={t [s]},
            samples=2000,
        ]
        \addplot[domain=0:100, red] {cos(2*pi*x)};
        \addplot[domain=0:100, blue] {cos(4*pi*x)};
        \addplot[domain=0:100, black, ultra thick] {cos(2*pi*x)*cos(4*pi*x)};
        \legend{cos(2t), cos(4t), produit}
        \end{axis}
        \node[] at (axis cs:55,1) {synchronises};
        \node[] at (axis cs:29,1) {desynchronises};
    \end{tikzpicture}
	\caption{Synchronisation entre deux cosinus de fréquences différentes}
	\label{fig:synchronisation}
\end{figure}
\end{center}

On fait ensuite une accumulation (une moyenne en quelque sorte) de ces mesures sur une période $T_s$ en élevant l'intégrale sur $T_s$ au carré, pour avoir une idée de la synchronisation avec le signal d'un bit 1 et d'un bit 0 à chaque instant échantilloné.

% TODO montrer l'intégrale pas juste le produit

\begin{center}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
        \begin{axis}[
            ymax=1.1, ymin=-1.1,
            ylabel={Amplitude},
            xlabel={t [s]},
            samples=1000,
        ]
        \addplot[domain=0:200, red, thick] {cos(2*pi*x) * (x<30*pi) + cos(4*pi*x) * (x>=30*pi)};
        \addplot[domain=0:200, blue, thick] {cos(4*pi*x)};
        \addplot[domain=0:200, black, ultra thick] {(cos(2*pi*x) * (x<30*pi) + cos(4*pi*x) * (x>=30*pi)) * cos(4*pi*x)};
        \legend{signal, cos(4t), produit}
        \end{axis}
    \end{tikzpicture}
	\caption{Synchronisation entre le signal obtenu et le signal théorique d'un bit}
\end{figure}
\end{center}

Finalement, pour chaque échantillon temporel (de durée $T_s$), on effectue une comparaison:

$$
\operatorname{reconstitué}(kT_s) = \begin{cases}
    1 & \text{si } \operatorname{sync}_1(kT_s) - \operatorname{sync}_0(kT_s) > 0 \\
    0 & \text{sinon}
\end{cases}
$$

En notant $\operatorname{sync}_b$ le produit pour le bit $b$.

Le signal démodulé avec cette méthode est le suivant:

\input{figures.v21.61/signal-demodule-synchro-parfaite.tex}


\subsection{Gestion d'une erreur de synchronisation de phase porteuse}



% ne pas écrire en dessous

\begin{center}
    \includegraphics[width=0.125\textwidth]{frog.jpg}
\end{center}
\end{document}
